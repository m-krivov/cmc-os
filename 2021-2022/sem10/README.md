# Межпроцессное взаимодействие

## Неименованные (анонимные) каналы

Одним из базовых средств межпроцессного взаимодействия являются анонимные (неименованные)
каналы. Они есть и в WinAPI (`CreatePipe`), и в POSIX-ориентированных
операционных системах. Часто они называются просто каналами &mdash; pipe.

Канал позволяет выполнять однонаправленную (симплексную) передачу потока байт.
Этим он, с одной стороны, отличается от сокета, который позволяет выполнять
двунаправленную (дуплексную) передачу данных, и, с другой стороны,
от очередей сообщений, которые позволяют выполнять передачу сообщений,
а не потока байт.

В POSIX канал создаётся системным вызовом `pipe`.

```c
#include <unistd.h>
int pipe(int filedes[2]);
```

При успешном завершении системный вызов возвращает 0, а при ошибке &mdash; `-1`, и переменная
`errno` устанавливается в код ошибки. Неуспешное завершение `pipe` скорее всего
означает, что переполнилась таблица открытых файлов у процесса либо у всей системы.
Системному вызову передаётся массив из двух элементов, в который этот системный вызов
записывает номера двух файловых дескрипторов. Два файловых дескриптора связаны
друг с другом. Данные записываются в файловый дескриптор `filedes[1]`.
Записанные данные можно прочитать из файлового дескриптора `filedes[0]`.

Можно считать, что `filedes[1]` ссылается на начало канала, `filedes[0]` &mdash; на конец канала
(если мы предполагаем, что данные «текут» от начала к концу). Реализация канала
подразумевает область памяти ограниченного размера (буфер),
расположенную в ядре ОС, в которой размещаются передаваемые через канал данные.
Запись в канал &mdash; это добавление данных в конец буфера, а чтение из канала &mdash;
это извлечение данных из начала буфера. То есть канал работает аналогично очереди
по дисциплине FIFO (first-in first-out). Важно заметить, что размер буфера в памяти ядра ОС
ограничен и фиксирован.

В результате создания нового процесса с помощью `fork`,
либо копирований файлового дескриптора с помощью `dup`, `dup2`, может быть создано
несколько файловых дескрипторов для записи в канал или несколько файловых
дескрипторов для чтения из канала. Для канала независимо отслеживается закрытие
записывающей стороны (начала канала) и считывающей стороны (конец канала).
Записывающая сторона считается закрытой, когда закрываются все файловые дескрипторы
для записи в канал.
Считывающая сторона считается закрытой, когда закрываются все файловые дескрипторы
для чтения из канала.
В структурах данных ядра ОС для этого используются счетчики ссылок.

Для работы с файловыми дескрипторами канала используются стандартные средства:
для записи в канал используется системный вызов `write` и его варианты,
для чтения из канала используется системный вызов `read`, для закрытия
файлового дескриптора &mdash; `close`. В системном вызове `write` можно
использовать только записывающий файловый дескриптор, а в системном вызове `read` &mdash;
только считывающий файловый дескриптор.
Размер буфера обмена, используемого
для временного хранения данных, передаваемых через канал, не стандартизирован.
Разные операционные системы используют разные размеры буфера.
Стандарт определяет константу `PIPE_BUF` (заголовочный файл `<limits.h>`), задающую минимальный размер
для буфера обмена, то есть гарантируется, что буфер обмена имеет
размер не меньший `PIPE_BUF`. Типичное значение этой константы &mdash; 4096 (4KiB).
В текущих версиях Linux размер буфера равен 65536 (64KiB) &mdash; в 16 раз больше.

При работе с каналами, именованными каналами, сокетами, терминалами
неприменимо понятие "текущей позиции в файле". Поэтому системный
вызов `lseek` и его варианты неприменимы к файловым дескрипторам каналов,
именованных каналов и т. п. Системный вызов `lseek` вернет значение `-1`,
переменная `errno` получит значение `ESPIPE`.

Поскольку обмен данными ведётся
через буфер фиксированного размера, при выполнении `read` и `write`
есть несколько возможных случаев, которые рассматриваются далее.

## Использование `read` для чтения данных из канала

Для каналов, именованных каналов и сокетов системный вызов `read` работает следующим образом:

1. Если в буфере канала есть данные (хотя бы один байт), системный вызов `read` скопирует
в буфер пользователя (то есть считает) данные из буфера канала частично или полностью.
Системный вызов `read` завершится немедленно, а процесс не будет заблокирован.
Размер считанных данных определяется минимальным значением из количества данных в буфере канала
в ядре и размером буфера, переданного в системный вызов `read`.

Например,
```c
    int fds[2];
    pipe(fds);
    char wbuf[2] = { 1, 2 };
    write(fds[1], wbuf, sizeof(wbuf)); // записываем в буфер канала в ядре ОС 2 байта
    char rbuf[4];
    ssize_t rsz = read(fds[0], rbuf, sizeof(rbuf)); // read завершится немедленно, rsz == 2, в начало rbuf будут записаны {1, 2}
```

но
```c
    int fds[2];
    pipe(fds);
    char wbuf[2] = { 1, 2 };
    write(fds[1], wbuf, sizeof(wbuf)); // записываем в буфер канала в ядре ОС 2 байта
    char rbuf[1];
    ssize_t rsz = read(fds[0], rbuf, sizeof(rbuf)); // read завершится немедленно, rsz == 1, в rbuf будут записаны {1}
```

Очень важно понимать, что `read` не переводит процесс в режим ожидания данных, если во внутреннем буфере ядра
уже есть какие-то данные, даже если их недостаточно для полного заполнения буфера, предоставленного пользователем
в системном вызове `read`. Это &mdash; общее свойство `read`, справедливое для любого типа файлового дескриптора,
включая регулярные файлы, сокеты, каналы, терминалы и т. д.

Если размер буфера пользователя, переданный в `read`, не больше `PIPE_BUF`, стандарт POSIX гарантирует, что копирование данных из буфера ядра в буфер
пользователя будет выполнено одной атомарной операцией. Атомарность здесь означает, что данные в буфер пользователя будут скопированы одним последовательным блоком.
Если два процесса выполняют `read` из одного и того же канала, то сначала будет скопирован блок для одного процесса, затем будет скопирован блок для другого процесса.
Де-факто в Linux операции чтения из канала с размером, не превышающим размер буфера ядра (то есть 64 KiB) атомарны.

Например, если в канал записаны 4 байта { 1, 2, 3, 4}, и два процесса одновременно выполняют операцию `read` с размером 2 байта, то возможны
всего два варианта: первый процесс считает {1, 2}, второй считает {3, 4}, либо первый процесс считает {3, 4}, второй процесс считает {1, 2}.

В случае больших размеров передаваемых в системный вызов `read` буферов атомарность операции чтения не гарантируется.

2. Если буфер канала в ядре ОС пуст, и записывающая сторона канала закрыта, системный вызов `read` возвращает 0, сигнализируя таким образом
о достижении конца файла. Данных из этого канала больше не будет, и считывающий процесс должен обработать эту ситуацию. Это может быть
закрытие файлового дескриптора и завершение работы программы.

3. Если буфер канала в ядре ОС пуст, но записывающая сторона канала не закрыта, то есть в каком-то процессе есть открытый файловый
дескриптор для записи в этот канал, то процесс, выполняющий чтение, будет заблокирован ядром ОС до наступления условий 1) или 2).
Несколько процессов могут быть заблокированы на чтении из одного канала, и тогда когда наступит условие 1) или 2) разбужены будут
все процессы. Возможно, правда, что часть из них снова будет переведена в режим сна из-за отсутствия данных в буфере канала в ядре ОС,
так как другие проснувшиеся процессы его опустошили.

"забытые" файловые дескрипторы записи в канал &mdash; это одна из типовых ошибок использования каналов. "забытые" файловые дескрипторы
приводят к тупику (дедлоку) в работе процессов, если процесс блокируется на системном вызове `read`, когда никакой процесс никогда
данные в канал записывать не будет.

Выше было описано поведение системного вызова `read` при работе
в стандартном (блокирующем) режиме. Файловый дескриптор
может быть переведен в неблокирующий режим. Тогда в тех
случаях, когда процесс был бы заблокирован, системный вызов
`read` вернет значение `-1` с кодом ошибки `EAGAIN` в переменной `errno`.

## Использование `write` для записи данных в канал

Для каналов, именованных каналов и сокетов системный вызов `write` работает следующим образом:

1. Если считывающая сторона закрыта, запись в канал считается ошибочной
операцией. В этом случае ядро ОС отправит процессу сигнал `SIGPIPE`,
который по умолчанию завершает выполнение процесса.
Если сигнал `SIGPIPE` игнорируется или блокируется, процесс не
завершается, но системный вызов `write` возвращает значение `-1` (признак
ошибки), а переменная `errno` будет содержать значение `EPIPE`.
Следует заметить, что завершение процесса по сигналу `SIGPIPE`
почти никогда не является желаемым поведением. Чтобы игнорировать
сигнал `SIGPIPE` и обрабатывать данную ситуацию как обычную ошибку записи
в начале программы достаточно выполнить

```c
    signal(SIGPIPE, SIG_IGN);
```

2. Если считывающая сторона не закрыта, размер записываемых данных
не превышает `PIPE_BUF`, и в буфере канала в ядре ОС достаточно места
для размещения всех записываемых данных, системный вызов `write`
атомарно копирует записываемые данные из буфера пользователя,
адрес которого передан в `write`, в конец буфера канала в ядре ОС.
Атомарность здесь означает, что никакая другая операция записи
в канал и чтения из канала не может выполняться одновременно с
копированием данных. Если несколько процессов выполняют атомарную
операцию записи в канал одновременно, операции записи будут
выполнены в каком-то порядке последовательно, и записываемые
данные не перемешаются. В случае Linux операция записи будет атомарной,
если размер записываемых данных не превышает размер буфера канала
в ядре ОС (64 KiB).

3. Если считывающая сторона не закрыта, но буфер канала
полностью заполнен, системный вызов `write` блокирует процесс
на неопределенное время, пока состояние буфера канала в ядре ОС
или файловых дескрипторов считывающей стороны канала не изменится.

4. Если считывающая сторона не закрыта, размер записываемых данных
не превывает ограничения атомарной записи (не менее `PIPE_BUF`, но
на Linux &mdash; 64 KiB), но свободного места в буфере канала в ядре ОС
недостаточно, чтобы полностью разместить записываемые данные,
системный вызов `write` также заблокирует процесс на неопределенное время,
пока состояние буфера канала или файловых дескрипторов считывающей стороны канала не изменится.

5. Если считывающая сторона не закрыта, но размер записываемых
данных превосходит ограничение атомарной записи, поведение
системного вызова `write` может различаться от системы к системе. Возможно,
`write` выполнит частичную запись немедленно, но возможно,
что `write` вернет управление в процесс только после того, как
весь пользовательский буфер будет передан в канал.

Как и в случае `read`, если файловый дескриптор переведен
в неблокирующий режим, в тех случаях, когда процесс был бы
заблокирован,
системный вызов
`write` вернет значение `-1` с кодом ошибки `EAGAIN` в переменной `errno`.

## Использование каналов для реализации конвейеров командного интерпретатора

Неименованные каналы используются для реализации
конвейеров интерпретатора командной строки shell и аналогичных.
Например, при выполнении команды

```
ls -l | wc -l
```

процесс, выполняющий команду `ls -l`, и процесс, выполняющий команду `wc -l`,
запускаются параллельно, стандартный вывод первого процесса
перенаправляется в канал (записывающую сторону),
а стандартный ввод второго процесса
перенаправляется из канала (считывающей стороны).

Фрагмент программы, реализующий такое перенаправление, может
выглядеть следующим образом (в данном фрагменте
программы не обрабатываются возможные ошибки
выполнения системных вызовов `pipe`, `fork` и других,
реализация обработки ошибок оставлена в качестве упражнения):

```c
    int pfd[2];  // массив для файловых дескрипторов канала
    pipe(pfd);
    pid_t pid1 = fork();
    if (!pid1) {
        // первый процесс: ls
        // перенаправить записывающую сторону канала
        dup2(pfd[1], 1);
        // закрыть файловые дескрипторы канала, они больше не нужны
        close(pfd[0]); close(pfd[1]);
        execlp("ls", "ls", "-l", NULL);
        // обязательно после exec должен быть _exit
        _exit(1);
    }
    // файловый дескриптор для записи в канал больше не нужен
    close(pfd[1]);
    pid_t pid2 = fork();
    if (!pid2) {
        // второй процесс: wc
        // перенаправить считывающую сторону канала
        dup2(pfd[0], 0);
        // файловый дескриптор канала больше не нужен
        close(pfd[0]);
        execlp("wc", "wc", "-l", NULL);
        _exit(1);
    }
    // отцу не нужен файловый дескриптор для чтения из канала
    close(pfd[0]);
    // отец должен дождаться завершения обоих сыновей
    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);
```

Закрывайте файловые дескрипторы (любые) как только они в
программе становятся больше не нужны! Это простое
правило гарантирует корректное использование
файловых дескрипторов канала и, как следствие, отсутствие
тупиков (зависаний) при работе.

## Системный вызов `pipe2`

ОС Linux предлагает полезный системный вызов `pipe2`.

```c
#define _GNU_SOURCE
#include <fcntl.h>
#include <unistd.h>

int pipe2(int pipefd[2], int flags);
```

Системный вызов становится доступным в заголовочных файлвх,
если при компиляции указан макрос `_GNU_SOURCE`. Обычно
его задают в командной строке компиляции с помощью опции
`-D_GNU_SOURCE`. Задавать его непосредственно в исходном тексте
программы, как показано на фрагменте выше, не стоит.

Системный вызов `pipe2` дополнительно к массиву для сохранения
файловых дескрипторов канала принимает параметр `flags`.
В нем можно указать флаги, с которыми будут созданы файловые
дескрипторы, что позволяет не использовать системный вызов
`fcntl` для модификации флагов уже открытых файловых дескрипторов.

Флаг `O_CLOEXEC` включает у файловых дескрипторов канала режим
"закрытия при exec", то есть файловые дескрипторы канала будут
закрыты автоматически при выполнении функций семейства `exec*`.
Обратите внимание, что флаг `O_CLOEXEC` не копируется при
копировании файловых дескрипторов с помощью системных вызовов
семейства `dup`, поэтому хотя файловый дескриптор, полученный
из `pipe2`, и будет закрыт при `exec*`, копии этого
файлового дескриптора при `exec*` сохранятся.

Флаг `O_NONBLOCK` включает неблокирующий режим у обоих
файловых дескрипторов канала. Флаг `O_NONBLOCK` копируется
при копировании файловых дескрипторов с помощью системных
вызовов семейства `dup`.

Использование системного вызова `pipe2` вместо `pipe`
позволяет немного упростить фрагмент кода, создающего
конвейер между двумя командами.

```c
    int pfd[2];  // массив для файловых дескрипторов канала
    pipe2(pfd, O_CLOEXEC);
    pid_t pid1 = fork();
    if (!pid1) {
        // первый процесс: ls
        // перенаправить записывающую сторону канала
        dup2(pfd[1], 1);
        // pfd[0], pfd[1] будут закрыты автоматически при execlp
        execlp("ls", "ls", "-l", NULL);
        // обязательно после exec должен быть _exit
        _exit(1);
    }
    // файловый дескриптор для записи в канал больше не нужен
    pid_t pid2 = fork();
    if (!pid2) {
        // второй процесс: wc
        // перенаправить считывающую сторону канала
        dup2(pfd[0], 0);
        // pfd[0], pfd[1] будут закрыты автоматически при execlp
        execlp("wc", "wc", "-l", NULL);
        _exit(1);
    }
    // отцу не нужны файловые дескрипторы канала
    close(pfd[0]); close(pfd[1]);
    // отец должен дождаться завершения обоих сыновей
    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);
```

## Использование каналов для синхронизации

Блокировка процесса при чтении из пустого канала
позволяет реализовать на каналах семантику семафоров.
А именно, канал, во внутреннем буфере которого нет данных,
можно рассматривать как закрытый (заблокированный) семафор,
а канал, в буфере которого содержатся данные, можно рассматривать
как открытый семафор. Сами данные в этом случае не важны,
важен только размер данных во внутреннем буфере канала.
Системный вызов `read` тогда выполняет роль операции
`down` блокировки семафора, а системный вызов `write`
выполняет роль операции `up` разблокировки семафора.

Может показаться, что в этом нет необходимости, учитывая то,
что POSIX-ориентированные операционные системы предлагают
различные варианты "настоящих" семафоров
(семафоры SysV IPC, семафоры POSIX, мьютексы/кондвары).
Однако работа с каналами ведется с помощью файловых
дескрипторов, и каналы можно использовать в системных
вызовах, работающих сразу с несколькими файловыми
дескрипторами, таких как `select`, `poll`, `epoll`.
Поэтому мы можем выполнять одновременно и ожидание
обмена данными на рабочих файловых дескрипторах (например,
дескрипторах сокета), так и ожидание наступления
некоторого события на файловом дескрипторе канала,
который используется как семафор. Это удобно в
многопоточных приложениях, в которых одна нить
выполняет операции ввода-вывода с помощью `select` или
аналогичных системных вызовов, и эту нить нужно
"разбудить" из другой нити.

В качестве примера рассмотрим следующую программу.
Процесс-отец создает двух сыновей. Сыновья, работая по очереди,
выводят на стандартный поток вывода свой порядковый
номер (1 или 2). В примере не обрабатываются
возможные ошибки при выполнении системных вызовов.

```c
// serial - порядковый номер процесса-сына (1, 2)
// rfd - для ожидания своей очереди вывода
// wfd - для уведомления другого процесса
void work(int serial, int rfd, int wfd)
{
    while (1) {
        // сами данные нас не интересуют, важно, чтобы был фиксированный
        // размер, в нашем случае берем sizeof(int)
        int val;
        // ожидаем своей очереди для работы
        read(rfd, &val, sizeof(val));
        // выводим свой порядковый номер
        printf("%d\n", serial); fflush(stdout);
        // разрешаем работать другому процессу
        write(wfd, &val, sizeof(val));
    }
}

int main(void)
{
    int p1[2]; // канал, на котором ждет первый сын
    int p2[2]; // канал, на котором ждет второй сын
    pipe(p1);
    pipe(p2);
    if (!fork()) {
        // первый сын
        work(1, p1[0], p2[1]);
        _exit(0);
    }
    if (!fork()) {
        // второй сын
        work(2, p2[0], p1[1]);
        _exit(0);
    }
    // отец должен разрешить работу какого-нибудь сына в первый раз
    {
        int val = 0;
        write(p1[1], &val, sizeof(val));
    }
    // ждем завершения всех сыновей, чего нормально не должно произойти никогда
    while (wait(NULL) > 0) {}
}
```

## Механизм `eventfd`

Если канал используется как семафор для взаимной блокировки или
уведомления другого процесса как показано выше, для этого
не требуется большой буфер для промежуточного хранения данных в ядре ОС, а память в ядре ОС является очень ценным ресурсом.
Поэтому Linux предлагает механизм `evenfd`, оптимизированный для такого случая.

eventfd &mdash; это один файловый дескриптор, над которым можно выполнять
системные вызовы `write` и `read`, причем системный вызов `write`
выполняет операцию `up` для семафора, а системный вызов `read` &mdash; операцию `down`.
Для файлового дескриптора eventfd не создается буфер для временного хранения
передаваемых данных в ядре ОС, поэтому произвольные данные передавать нельзя,
однако в ядре поддерживается 64-битное значение &mdash; счетчик семафора.

Файловый дескриптор для eventfd создаётся с помощью соответствующего системного вызова.

```c
#include <sys/eventfd.h>

int eventfd(unsigned int initval, int flags);
```

Параметр `initval` задаёт начальное значение для 64-битного беззнакового счетчика
(младшие 32 бита значения).
Параметр `flags` позволяет задать дополнительные флаги.
В случае успеха системный вызов возвращает файловый дескриптор, в случае ошибки
возвращается `-1` и переменная `errno` устанавливается в код ошибки.

Поддерживаются следующие значения флагов. Они могут объединяться с помощью
операции побитового или.

* `EFD_CLOEXEC` &mdash; активирует режим закрытия данного файлового
дескриптора при exec.

* `EFD_NONBLOCK` &mdash; сразу создает файловый дескриптор в неблокирующем режиме.

* `EFD_SEMAPHORE` &mdash; включает режим "семафора" при выполнении системного вызова `read`.

Системный вызов `write` работает следующим образом: в качестве буфера для записи должен
передаваться адрес 64-битной переменной типа `uint64_t` (то есть 64-битное беззнаковое
целое число в порядке байт хоста), а размер записываемых данных должен быть равен 8.
В случае успешного завершения `write` возвращает 8.
Если при сложении переданного в `write` значения и счетчика семафора происходит
64-битное беззнаковое переполнение, системный вызов `write` заблокирует процесс
до тех пор, пока значение счетчика не станет таким, что сложение со значением,
переданным в `write` не будет представимым 64-битным беззнаковым числом.
Это будет новое значение семафора. Проверка переполнения и присваивание нового
значения является атомарной операцией. Как и в случае канала, если несколько
процессов заблокированы на `write`, разбужены будут все процессы, но возможно,
часть из них будет заблокированы снова.

Системный вызов `read` работает немного по-разному в зависимости от режима `EFD_SEMAPHORE`.
В любом случае в системный вызов должен быть передан адрес переменной типа `uint64_t`,
размер считываемых данных должен быть 8. В случае успешного завершения `read` возвращает 8.
Если счетчик семафора eventfd равен 0, процесс будет заблокирован до тех пор,
пока счетчик семафора не изменится.

В режиме по умолчанию если счетчик семафора не равен 0, значение счетчика
копируется в переменную, адрес которой передан в `read`, после чего
значение счетчика сбрасывается в 0. Операция атомарная.

В режиме семафора (`EFD_SEMAPHORE`) если счетчик семафора не равен 0,
в переменную, адрес которой передан в `read`,
записывается значение 1, и значение счетчика уменьшается на 1. Операция атомарная.

В качестве примера рассмотрим ту же самую задачу, что и в предыдущем разделе.
Процесс-отец создает двух сыновей. Сыновья, работая по очереди,
выводят на стандартный поток вывода свой порядковый
номер (1 или 2). В примере не обрабатываются
возможные ошибки при выполнении системных вызовов.

```c
// serial - порядковый номер процесса-сына (1, 2)
// rfd - для ожидания своей очереди вывода
// wfd - для уведомления другого процесса
void work(int serial, int rfd, int wfd)
{
    while (1) {
        // сами данные нас не интересуют, важно, чтобы был фиксированный
        // размер, в нашем случае берем sizeof(int)
        uint64_t val = 0;
        // ожидаем своей очереди для работы
        read(rfd, &val, sizeof(val));
        // выводим свой порядковый номер
        printf("%d\n", serial); fflush(stdout);
        // разрешаем работать другому процессу
        write(wfd, &val, sizeof(val));
    }
}

int main(void)
{
    int p1 = eventfd(1, 0);  // начальное значение 1, стандарный режим работы
    int p2 = eventfd(0, 0);  // начальное значение 0, стандарный режим работы
    if (!fork()) {
        // первый сын
        work(1, p1, p2);
        _exit(0);
    }
    if (!fork()) {
        // второй сын
        work(2, p2, p1);
        _exit(0);
    }
    // ждем завершения всех сыновей, чего нормально не должно произойти никогда
    while (wait(NULL) > 0) {}
}
```

## Именованные каналы (fifo)

Именованные каналы отличаются от неименованных тем, что (сюприз!) у именованных
каналов есть имя, а точнее, наличием индексного дескриптора в файловой системе, к которому
привязывается канал. Индексный дескриптор может иметь одно или несколько имен в файловой
системе, на эти имена могут ссылаться символические ссылки. Для открытия считывающей
или записывающей стороны именованного канала используется обычный системный вызов `open`
или его варианты.

Именованный канал, привязанный к индексному дескриптору, может быть либо в "неактивном",
либо в "активном" состоянии. Именованный канал переходит из неактивного в активное состояние,
когда в системе появляются открытые файловые дескрипторы, позволяющие и записывать в канал,
и считывать из него. Вполне достаточно одного файлового дескриптора, который позволяет
и считывать из файла, и записывать его (режим `O_RDWR`), но обычно это пара файловых дескрипторов:
один, работающий в режиме "только чтение" (`O_RDONLY`), второй, работающий в режиме "только запись"
(`O_WRONLY`). У активного неименованного канала в ядре ОС находится буфер канала, который
используется для временного хранения данных, передаваемых через канал. Этот буфер имеет
тот же размер, что и для неименованного канала. Для неактивного именованного канала
никакой информации, кроме индексного дескриптора, не хранится. Обратите внимание,
что данные, передаваемые через именованный канал, хранятся только в буфере канала в ядре ОС.
Эти данные не хранятся нигде в файловой системе, то есть у именованного канала нет
блоков данных, хранящихся в файловой системе.

Если именованный канал находится в активном состоянии, операции его открытия
возвращают файловые дескрипторы, работающие с уже созданным буфером канала в ядре, то
есть, можно сказать, что открытие активного именованного канала подключает файловый
дескриптор к уже существующему каналу. Именованный канал закрывается, индексный
дескриптор переходит в неактивное состояние, и все ресурсы, выделенные под него в ядре ОС
освобождаются, когда закрывается последний файловый дескриптор, связанный с именованным каналом.
Если в буфере канала были какие-то данные, они теряются. Перезагрузка операционной системы
сбрасывает все именованные каналы в неактивное состояние.

Для создания индексного дескриптора именованного канала используется библиотечная функция
`mkfifo`.

```c
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);
```

Аргумент `pathname` &mdash; это относительный или абсолютный путь в файловой системе.
Аргумент mode &mdash; права доступа на создаваемый именованный канал. Права доступа, как обычно, модифицируются
маской прав открытия файла `umask` процесса.

Как обычно, в случае успеха функция возвращает 0, а при неудачном завершении — `-1`,
и в этом случае переменная `errno` будет установлена в код ошибки. Например,
если файл с таким именем существует, функция завершается с ошибкой `EEXIST`.

Удалить индексный дескриптор именованного канала можно с помощью системного вызова `unlink`.
Как и в случае регулярных файлов, индексный дескриптор будет реально освобожден тогда,
когда закроется последний файловый дескриптор, связанный с данным именованным каналом.

Для открытия именованного канала используется системный вызов `open`.
В POSIX стандартизовано только два режима открытия: только на чтение (`O_RDONLY`)
и только на запись (`O_WRONLY`). Естественно, процесс может открыть два файловых дескриптора:
один на чтение, другой на запись.
Процесс, открывающий именованный канал на запись, будет заблокирован до тех пор,
пока не появится процесс, открывший именованный канал на чтение.
То же самое верно и в обратную сторону.

Процесс, который собирается сам и читать из именованного канала, и писать в него,
должен открывать канал специальным образом, чтобы избежать блокировки. Сначала процесс
должен открыть канал на чтение в неблокирующемся режиме, после этого открыть канал на
запись в нормальном режиме, и после сбросить неблокирующий режим на дескрипторе чтения
из канала. Фрагмент программы, открывающей именованный канал, приведён ниже (все
возможные ошибки игнорируются для краткости записи).

```c
    /* открываем дескриптор чтения в неблокирующем режиме */
    int fdr = open("fifo", O_RDONLY | O_NONBLOCK);
    /* открываем дескриптор записи */
    int fdw = open("fifo", O_WRONLY);
    /* сбрасываем флаг неблокирующего доступа */
    fcntl(fdr, F_SETFL, fcntl(fdr, F_GETFL) & ~O_NONBLOCK);
```

Два процесса, которые используют именованные каналы для обмена данными,
могут попасть в состояние дедлока, если будут открывать их в неправильном порядке.

Неправильно:
```c
   // процесс 1
   int fdr = open("fifo1", O_RDONLY);
   int fdw = open("fifo2", O_WRONLY);

   // процесс 2
   int fdr = open("fifo2", O_RDONLY);
   int fdw = open("fifo1", O_WRONLY);
```

Правильно:
```c
   // процесс 1
   int fdr = open("fifo1", O_RDONLY);
   int fdw = open("fifo2", O_WRONLY);

   // процесс 2
   int fdw = open("fifo1", O_WRONLY);
   int fdr = open("fifo2", O_RDONLY);
```
Сначала полностью открывается `"fifo1"`, затем полностью открывается `"fifo2"`.

Ядро Linux расширяет стандарт POSIX и поддерживает открытие именованного канала
в режиме `O_RDWR`. В этом случае будет получен файловый дескриптор,
который позволяет и считывать из канала, и записывать в канал, и
и канал сразу же будет переведен в активное состояние, если был неактивным.
Это может помочь избежать дедлоков при открытии канала, но, может привести
к дедлокам при последующей работе с каналом, так как пока открыт файловый дескриптор
канала, работающий в режиме `O_RDWR`, невозможно будет получить признак конца файла
при чтении из канала или ошибку записи при записи в канал. 

## Использование высокоуровневых дескрипторов потока (FILE*) с каналами

С файловыми дескрипторами каналов можно работать с помощью системных вызов `read` и `write`.
Может оказаться удобнее работать с каналом с помощью высокоуровневых
дескрипторов потока. Можно скопировать файловые дескрипторы каналов в файловые
дескрипторы 0 или 1 с помощью системного вызова `dup2`, а затем использовать
стандартные потоки `stdin` и `stdout` для ввода-вывода.

С другой стороны можно использовать библиотечную функцию `fdopen` для привязки
высокоуровневых дескрипторов потока к файловым дескрипторам. Например,

```c
    int pfd[2];
    pipe(pfd);
    FILE *rf = fdopen(pfd[0], "r");
    FILE *wf = fdopen(pfd[1], "w");
```

Дескрипторы потоков `rf` и `wf` можно использовать для чтения высокоуровневыми
средствами (например, `fscanf`) и записи высокоуровневыми средствами (например, `fprintf`)
соответственно. Файловые дескрипторы `pfd[0]` и `pfd[1]` передаются "во владение"
дескрипторам потока `rf` и `wf`, поэтому их не нужно закрывать с помощью `close`,
они будут закрыты, когда закрывается дескриптор потока либо с помощью `fclose`
либо при завершении процесса.

Работа с высокоуровневыми дескрипторами потоков с нижележащими файловыми
дескрипторами каналов имеет следующие особенности.

* Дескриптор потоков будет полностью буферизован. Данные будут накапливаться
в буфере дескриптора потока, пока он полностью не заполнится, не будет закрыт,
или данные не будут вытолкнуты явно. Поэтому если необходимо,
чтобы данные были отправлены в канал немедленно, используйте вызов `fflush`
на дескрипторе потока записи. Например,

```c
    fprintf(wf, "Hello"); fflush(wf);
```
С другой стороны, можно поменять режим буферизации высокоуровнего
дескриптора потока с помощью библиотечной функции `setbuf` и аналогичных.
Но предпочтительнее, пожалуй, использовать вариант с `fflush`.

* Высокоуровневые потоки обычно работают с данными в текстовом формате,
то есть если дана переменная `int val;` то при записи в высокоуровневый
поток обычно используется `fprintf`,
а для чтения обычно используется `fscanf`.
Но если в одном процессе сделать

```c
    int val;
    fprintf(wf, "%d", val); fflush(wf);
```

а в другом процессе

```c
    int val;
    fscanf(rf, "%d", &val);
```

второй процесс может неожиданно "зависнуть" на неограниченное время
в системном вызове `read`, вызываемом из `fscanf`.
Проблема возникает в том, что функция `fscanf` не может определить,
что текстовое представление переданного числа завершилось, так
как текстовое представление (в отличие от бинарного представления)
имеет заранее неизвестную длину при чтении. Поэтому функция `fscanf`
ожидает либо признака конца файла, либо символа, который не может быть
частью числа, например, пробельного символа `' '` или `'\n'`.
Поэтому при выводе числа в текстовом представлени в канал необходимо
сразу вывести символ, который будет означать, что число окончилось.
Поэтому правильно в канал выводить так:

```c
    int val;
    fprintf(wf, "%d\n", val); fflush(wf);  // обязательно добавляем \n и не забываем fflush
```

* Каналы не являются файлами произвольного доступа, с ними не работает системный вызов
`lseek` и аналогичные. Поэтому для считывающего дескриптора потока нельзя использовать
вызов `fflush`.

